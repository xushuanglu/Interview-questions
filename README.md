## 面试问题



### JVM面试题

- Javs中会存在内存泄漏吗，请简单描述。
内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。

理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。

但是，即使这样，Java也还是存在着内存泄漏的情况，
1、长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露。

    尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是Java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。

检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

2、当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露

- Serial与Parallel GC之间的不同之处?
- 32位和64位的JMM; int类型变量的长度是多数?
- Java中WeakReference 与SoftReference 的区别?
- JVM选项-XX: +IUseCompressed0ops有什么作用?为什么要使用
- 怎祥通过Java 程序来判断JyM是32位还是64位?
- 32位JVM和64位JM的最大堆内存分别是多数?
- JhE、JDK、JVM及JIT之间有什么不同?
- 解释Java堆空间及GC?
- JM内存区域
- 程序计数器(线程私有)
- 虚拟机栈线程私有)
- 本地方法区(线程私有)
- 你能保证GC执行吗?
- 怎么获取Java程序使用的内存?堆使用的百分比?
- Java中堆和栈有什么区别?
- 描述一下JyM加载class文件的原理机制
- GC是什么?为什么要有GC?
- 堆(Heap-线程共享)运行时数据区
- 方法区/永久代(线程共享)
- JVM运行时内存
- 新生代
- 老年代
- 永欢代
- JAVA8与元数据
- 引用计数法
- 可达性分析
- 标记清除算法( Mark -Sweep)
- 复制算法( copying)
- 标记整理算法0M ark Compact)
- 分代收集算法
- 新生代与复制算法
- 老年代与标记复制算法
- JAVA强引用
- JAVA软引用